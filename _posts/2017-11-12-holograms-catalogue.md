---
layout: single
title: Holograms Catalogue
date: 2017-11-12 10:39
author_profile: true
comments: true
categories: [HoloLens, Unity]
header:
    teaserlogo: 'assets/images/'
    teaser: 'assets/images/'
---
<h2>Shared Holograms Catalogue</h2><p>Iâ€™ve decided to break this post up into separate topics as when I got into this I realised there are a number of natural sections with their own merit. So think of this as a trip through my thought process as I put together a sample app.<blockquote><p>The aim of the project is to create an app which allows the user to consume a catalogue of 3D models, view them with a HoloLens and also have other participants view the same hologram. The project will be hosted here <a title="https://github.com/peted70/gltf-loading" href="https://github.com/peted70/gltf-loading">https://github.com/peted70/gltf-loading</a>&nbsp;</p></blockquote><h2>Dependency Injection</h2><p>This may not seem absolutely necessary for a sample app but early in my career I learnt the hard way that anticipating change and coding against abstractions was almost always the best way to begin writing *any* software. I would argue that samples benefit the most from this since dependencies can be more easily understood and reconfigured and also the easier a sample is to keep up to date the less likely it is that the sample will become obsolete and potentially counter-productive to the reader. Of course there is a trade-off here between obscuring the main point of the sample with extraneous code and reaping the benefits of DI.<p>I had previously been in the practice using some kind of <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank">dependency injection</a> in my apps but since working with Unity I had fallen out of that practice. This post gives me a chance to revisit and after some short research I found <a href="https://github.com/modesttree/Zenject" target="_blank">Zenject</a> and decided to give it a try.<p>For this sample I wanted to have an online model catalogue so the first job for DI was to hide the apps data retrieval behind an interface and have that configured by Zenject. I started with a dummy implementation of the interface:<script src="https://gist.github.com/peted70/4a1df21949ce7cfe81cfcc12d6b11a0a.js"></script><p><br><p>Note that I'm using a Task-based async interface; enabled by using the experimental <strong>.net 4.6 support </strong>in Unity.<p><a href="http://peted.azurewebsites.net/wp-content/uploads/2017/11/net46unity.png"><img width="711" height="334" title="net46unity" style="display: inline; background-image: none;" alt="net46unity" src="http://peted.azurewebsites.net/wp-content/uploads/2017/11/net46unity_thumb.png" border="0"></a><p>Then, adding Zenject to the project using the Asset store. <p><a href="http://peted.azurewebsites.net/wp-content/uploads/2017/11/Add-Zenject.png"><img width="724" height="535" title="Add Zenject" style="display: inline; background-image: none;" alt="Add Zenject" src="http://peted.azurewebsites.net/wp-content/uploads/2017/11/Add-Zenject_thumb.png" border="0"></a><p>Next a Zenject SceneContext needs to be added to the scene which is facilitated with a menu editor option:<p><a href="http://peted.azurewebsites.net/wp-content/uploads/2017/11/Zenject-SceneContext.png"><img width="729" height="817" title="Zenject SceneContext" style="display: inline; background-image: none;" alt="Zenject SceneContext" src="http://peted.azurewebsites.net/wp-content/uploads/2017/11/Zenject-SceneContext_thumb.png" border="0"></a><p>And finally, a Zenject Installer script is needed, again this can be added using an editor extension:<p><a href="http://peted.azurewebsites.net/wp-content/uploads/2017/11/Zenject-Installer.png"><img width="731" height="831" title="Zenject Installer" style="display: inline; background-image: none;" alt="Zenject Installer" src="http://peted.azurewebsites.net/wp-content/uploads/2017/11/Zenject-Installer_thumb.png" border="0"></a><p>The installer is the script where you can configure the dependencies for the app. I added code to supply an IHologramCollection implemented by the concrete class HologramCatalog with a view to replacing this later on with a real cloud catalogue.<script src="https://gist.github.com/peted70/32320cb26154fda6687a65c12fef8134.js"></script><p><br><p>Now I can create a Monobehaviour-derived class to handle data retrieval. It's necessary to declare a function to inject the interfaces here, amd decorate with the Inject attribute. (Note, I'm also injecting an ILogger interface here).<script src="https://gist.github.com/peted70/4fd0408eba7f12a96cb94b3b34a058e8.js"></script><p><br><p>Now, with the help of async/await we can call the interface and action the data items returned:<script src="https://gist.github.com/peted70/5e95ec3e85dbcbe1f464fb5407d3ec12.js"></script>
