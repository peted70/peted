---
layout: post
title: HoloLens: FBX Loading c++
date: 2017-05-10 20:54
author: peted70
comments: true
categories: [3D, ANGLE, angle, c#, c++, fbx, HoloLens, HoloLens, import, opengl, opengles2]
---
<p><a href="http://peted.azurewebsites.net/wp-content/uploads/2017/05/final.png"><img title="final" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="final" src="http://peted.azurewebsites.net/wp-content/uploads/2017/05/final_thumb.png" width="734" height="415"></a></p> <p>Now, there are a few reasons why you might want the ability to load FBX files; maybe you want to load 3D model files dynamically or you are working on a native HoloLens app and just want a way to get 3D data in to render, animate, etc. If you are building in Unity you have the option of using Asset Bundles which you can host on a server and access via an API. There are a few reasons why you may not want this though; you have an API already supplying the data in another format or you are building an API to be shared amongst other apps which you don’t want to tie to Unity. Authoring the bundles also requires Unity which may or may not be convenient. If you want to load FBX files dynamically in a Unity built app and didn’t want to use Asset Bundles then you could use similar code to that which I will show here and wrap it up as a Unity custom plugin. I believe there are some offerings in the Unity Asset store which would achieve a similar goal but I haven’t used them so can’t vouch for going that route.</p> <blockquote> <p>For one reason or another I have chosen to start this project as a native c++ app based on a template for ANGLE (Almost Native Graphics Layer Engine). This allows me to develop my rendering code with OpenGL ES 2.0 and have that run on a HoloLens. It does this by efficient translation of OpenGL to the equivalent Direct3D. I will come back to this in a subsequent blog post. You can find the project <a href="https://github.com/Microsoft/angle" target="_blank">here</a>.</p></blockquote> <p>The Microsoft fork of ANGLE has a branch named <a href="https://github.com/Microsoft/angle/tree/ms-holographic-experimental">ms-holographic-experimental</a> for experimental use on HoloLens. This branch has a template for Visual Studio 2015 so I used this as a starting point for my demo app. </p> <p><a href="http://peted.azurewebsites.net/wp-content/uploads/2017/05/vs-template.png"><img title="vs-template" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="vs-template" src="http://peted.azurewebsites.net/wp-content/uploads/2017/05/vs-template_thumb.png" width="746" height="518"></a></p> <p>This is the output from that template when run on a HoloLens:</p> <p><a href="http://peted.azurewebsites.net/wp-content/uploads/2017/05/blank-template-running.png"><img title="blank-template-running" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="blank-template-running" src="http://peted.azurewebsites.net/wp-content/uploads/2017/05/blank-template-running_thumb.png" width="733" height="410"></a></p> <p>So, it’s just a cube with per-vertex colours which floats in mid-air in front of you and spins. The interesting thing about it is that the rendering code is all OpenGL ES. </p><script src="https://gist.github.com/peted70/ba87c0483ffde5ceb8bedc6d0a5894b6.js"></script> <p>This snippet shows the Draw calls. Notice that the code will render for holographic and non-holographic apps and here you can see the difference.The else block is standard but look at the holographic part; two rendering targets are specified, one for each eye and there is a call to <strong>glDrawElementsInstancedANGLE </strong>which will instance the geometry saving performance when rendering the same scene to each eye.<strong>&nbsp;</strong>&nbsp;</p> <h2>FBX SDK</h2> <p>If I cast my mind back many years I can recall working with a company called Kaydara on integration of motion control rig paths as a plugin to their software Filmbox which I believe is where the FBX format originates. It is now all over and seems to be about as close as we get to a standard although it is a proprietary format owned by Autodesk. Enter stage left, gltf <a title="https://github.com/KhronosGroup/glTF" href="https://github.com/KhronosGroup/glTF">https://github.com/KhronosGroup/glTF</a> which is hopefully the open standard we are all moving towards. </p> <blockquote> <p>You can download the FBX SDK from here <a title="http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&amp;id=10775847" href="http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&amp;id=10775847">http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&amp;id=10775847</a> including a UWP version.</p></blockquote> <p>That’s what I did and I added it to my project – here are the steps:</p> <p>- Copy the include and lib folders from the FBX SDK install folder and paste them into a folder local to your project</p> <p>- I usually copy the dll and pdb into the root of my project and use ‘show files’ and ‘include in project’ to add the dll to the project.</p> <p>- Select the libfbxsdk.dll in your project and use the property window to mark it as content – ensuring that it will get copied to the output correctly</p> <p>- Add the include folder as an additional include folder in your project properties – I add it so it is referenced locally (rather than full path name)</p> <p>- In the Linker &gt; input settings add the .lib file from the FBX SDK</p> <blockquote> <p>Note. I have copied all of the dependencies locally and referenced them relatively – this is to make the solution self-contained</p></blockquote> <p>Now you should be able to add code like the following and have it compile and run:</p> <h3><script src="https://gist.github.com/peted70/3793ab3f7730659add53befb1760d41d.js"></script>Loading a File</h3> <p>Here’s some boilerplate code for loading a file:</p><script src="https://gist.github.com/peted70/84c3f21872b8a132e7f93e8b2d33633d.js"></script> <p>This will give us everything we need via the scene to load meshes, materials, textures, animations, etc.</p> <h3>Loading a Mesh</h3> <p>Now an FBX file can consist of a complex hierarchy of objects including meshes so in order to load the whole model we’ll need to traverse the whole data structure and create vertex buffers for each mesh. To help traverse the scene we can use a recursive function to which we pass a function object to be called for each mesh:</p> <p><script src="https://gist.github.com/peted70/0d4f5d912d6a4b23c1e279c1a56f204e.js"></script>we can pass a callback and query the scene data for information that we can use to populate our OpenGL buffers:</p><script src="https://gist.github.com/peted70/56950a8e9397680a6f6bceddc074c336.js"></script>In a similar way we can get the vertex indices which define how the triangles are constructed. In the actual project I have refactored the code a bit to provide a <strong>Model </strong>class which has a list of meshes which in turn are responsible for the individual buffers for vertices, indices and normals, etc. and also responsible for issuing the Draw calls. At this point we have a model that renders but it has no material properties or lighting so it just looks like a blob.&nbsp;&nbsp; <strong>&nbsp;</strong>&nbsp; <h3>Materials</h3> <p>To make this code in any way useful we need to apply some materials or at least some colours to the meshes. When I first started the plan was to re-write the shaders and apply different materials to the meshes and have them rendered correctly. I have taken a shortcut in the interests of time as things started to get a bit more complicated with the FBX SDK when we start to dig into materials.This is what I have implemented so far:</p> <blockquote> <p>Loop through the triangles of each mesh and discover the material applied to each. I then construct a buffer of vertex colours and derive those colours from the diffuse colour given in each material. I store the colour for each vertex and this allows me to continue to use the original fragment shader but still be able to differentiate between the different meshes in the model. </p></blockquote> <p>Here’s the snippet of code that collects the vertex colours:</p><script src="https://gist.github.com/peted70/682a5f6617a71304fd3c626c00a9c20f.js"></script> <h3>Next Steps</h3> <p>The next steps would be to re-implement the shaders to have a standard set that could be mapped to the materials in the FBX and also implement a lighting model. Then import the animation and we’ll get close to having something useful.</p> <p>Here’s the resulting model (of a HoloLens device) running on my HoloLens (the colours look a bit strange due to the per-vertex interpolation)</p> <p><iframe height="315" src="https://www.youtube.com/embed/cKsSn49UNhQ?ecver=1" frameborder="0" width="560" allowfullscreen></iframe></p> <p>And all of the source code for the project can be found here <a title="https://github.com/peted70/hololens-fbx-viewer" href="https://github.com/peted70/hololens-fbx-viewer">https://github.com/peted70/hololens-fbx-viewer</a></p>
