---
layout: single
title: HoloLens &amp; 3D Mapping
date: 2017-02-05 20:06
author_profile: true
comments: true
categories: [HoloLens, HoloLens, unity, Unity]
excerpt: "What I can help with though is sharing what I have learned and hopefully helping you with a starting point if like a past me you want to get up and running. I am also not trying to replace or undermine any of the commercial offerings here; instead I used this exploration to aid my own understanding and would reach for those in any commercial setting..."
header:
    teaserlogo: 'assets/images/2017/02/holomaps.jpg'
    teaser: 'assets/images/2017/02/holomaps.jpg'
---
<p><sub></sub>This is not specific to HoloLens but I am approaching the problem from that perspective as that is of most interest to me right now. All of the code can be found in a Github repo <a href="https://github.com/peted70/geojsontomesh" target="_blank">here</a>. The code and concepts will apply across the board and could be useful in any situation that involves sourcing data around real buildings and representing them in 3D – more specifically in Unity. I imagine this could help with multiple scenarios:</p> <blockquote> <p>Creating a proof-of-concept which enables real-time data to be overlayed onto or incorporated into 3D map data (this is the scenario that prompted me to investigate)</p></blockquote> <blockquote> <p>Providing a starting point for a scene set in a real location</p></blockquote> <blockquote> <p>Facilitating a more dynamic fly-through which could update in real-time as you navigate around streets or the globe</p></blockquote> <p>This won’t provide an experts view on mapping data as I am not an expert and this seems like a complex area – my previous experience here has been placing some pins on a map for a 2D mobile app! What I can help with though is sharing what I have learned and hopefully helping you with a starting point if like a past me you want to get up and running. I am also not trying to replace or undermine any of the commercial offerings here; instead I used this exploration to aid my own understanding and would reach for those in any commercial setting. By the way, if you make one of these or can recommend a good one for use in HoloLens apps please send a note in the comments and I will be happy to review in another post.</p> <blockquote> <p><font style="background-color: #ffffff">I have tried HoloMaps (which is excellent) but I couldn’t find a public API to the 3D Bing data used to try out</font></p></blockquote> <p><a href="{{ site.baseurl }}/assets/images/2017/02/holomaps.jpg"><img title="holomaps" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="holomaps" src="{{ site.baseurl }}/assets/images/2017/02/holomaps_thumb.jpg" width="730" height="416"></a></p> <p>&nbsp;</p> <p>From my initial research I quickly found that there is a JSON internet standard (<a href="https://tools.ietf.org/html/rfc7946" target="_blank">GeoJSON</a>) used to share geometry data which seemed to be fairly easy to understand and use. I decided to run with that and first build a component in Unity to generate a 3D mesh from GeoJSON; thinking was that I would later be able to find an API or service to retrieve GeoJSON data and plug that in. Since we’ll be using an open standard the hope is that the data source can be switched out for an alternative depending on app requirements.</p> <h3>Rendering GeoJSON in Unity</h3> <p>I started out by getting a GeoJSON sample:</p> <p><a href="{{ site.baseurl }}/assets/images/2017/02/geoJSON-sample.png"><img title="geoJSON sample" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="geoJSON sample" src="{{ site.baseurl }}/assets/images/2017/02/geoJSON-sample_thumb.png" width="725" height="407"></a></p> <p>It is possible to use the Open Street Map site <a href="https://www.openstreetmap.org/export#map=17/51.58025/-0.33601" target="_blank">here</a> to get data back in the format .osm by specifying a bounding box formed from the latitude and longitude coordinates.</p> <p><a href="{{ site.baseurl }}/assets/images/2017/02/overpass-turbo.png"><img title="overpass-turbo" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="overpass-turbo" src="{{ site.baseurl }}/assets/images/2017/02/overpass-turbo_thumb.png" width="737" height="419"></a></p> <p>I wanted GeoJSON though and after some further digging I found that you can access <a href="https://www.openstreetmap.org" target="_blank">OpenStreetMap</a> from the <a href="http://wiki.openstreetmap.org/wiki/Overpass_API" target="_blank">Overpass API</a> which has a <a href="https://overpass-turbo.eu/" target="_blank">tool</a> to facilitate this which uses it’s own query language for requests.</p> <p><a href="{{ site.baseurl }}/assets/images/2017/02/exportgj.png"><img title="exportgj" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="exportgj" src="{{ site.baseurl }}/assets/images/2017/02/exportgj_thumb.png" width="731" height="634"></a></p> <p>I used the tool to get myself some test data which I used to work out how to render the 3D buildings. </p> <h3>Unity Custom Editor</h3> <p>My initial goal was to create a tool that I could use in the Unity editor to generate the building geometry as opposed to a more dynamic control to let the end user explore a map but I may look into that next. Unity supports <a href="https://docs.unity3d.com/Manual/editor-CustomEditors.html" target="_blank">custom editors</a> and the approach I took was to create a MonoBehaviour script to be attached to a game object which has an associated custom editor script. These two scripts work together to extend the game object and provide an editor user interface to be able to control how the game object gets extended. First the MonoBehaviour-derived script<script src="https://gist.github.com/peted70/13252bfd1b2c7603d2030edb5b133f0a.js"></script> Then the editor itself (derived from the Editor base class): <script src="https://gist.github.com/peted70/5d79ce56799305cabe8c2f8e648bad9b.js"></script>It’s important to keep in mind that the Editor-derived script is designed to only be run in the Unity editor but the MonoBehaviour is designed to be run in-game and is associated with a Game Object (we don’t want any dependency on the UnityEditor namespace here). I think that this approach makes sense as the plan is to create something that runs in-game ultimately. Given that the input at this stage is a JSON file we need to find a way to get this data into memory, a job I usually reserve for JSON.NET but there seem to be a few challenges getting this to work with Unity (see <a title="http://www.what-could-possibly-go-wrong.com/unity-and-nuget/" href="http://www.what-could-possibly-go-wrong.com/unity-and-nuget/">http://www.what-could-possibly-go-wrong.com/unity-and-nuget/</a>). Instead, I searched around and found <a href="https://github.com/jacobdufault/fullserializer" target="_blank">fullserializer</a> and decided to give that a try instead. On the whole that decision worked out very well as this seems like a robust and flexible JSON serializer – I did run into this <a href="https://github.com/jacobdufault/fullserializer/issues/124" target="_blank">issue</a> though and needed to make some changes to the source code but I was bought in enough to warrant the extra effort.</p> <p>One inconvenience with using a custom editor is that Unity <a href="https://docs.unity3d.com/Manual/Coroutines.html" target="_blank">Coroutines</a> don’t run in this environment as they need an update loop to keep running. It is straight-forward to make use of the EditorApplication.update event in order to provide that update loop but it does need the code to be written. <a href="https://gist.github.com/benblo/10732554" target="_blank">Here’s</a> an example of the type of code needed for this.</p> <p>In order to keep a clear separation between the MonoBehaviour and the custom editor I used interfaces; </p> <blockquote> <p>IProgress – allowed calls to update a progress dialog </p> <p>IUpdateHandler – facilitated hooking a callback to run coroutines from the editor</p> <p>IDialog – allowed calls to show a dialog box&nbsp; </p></blockquote> <p>To use you can add an empty GameObject into your scene and then add the <strong>ThreeDMapScript</strong> as a new component to that GameObject. The custom editor for this component will provide some inputs to allow you to define a bounding box in terms of latitude and longitude. Also, you can specify the height of the levels used for the buildings. This could also be sourced from other data sets so could be a more accurate representation of the building heights.</p> <p><a href="{{ site.baseurl }}/assets/images/2017/02/custom-editor.png"><img title="custom editor" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="custom editor" src="{{ site.baseurl }}/assets/images/2017/02/custom-editor_thumb.png" width="730" height="291"></a></p> <p>Once set the <strong>Generate Map</strong> button will cause the script to call the REST API to retrieve the GeoJSON and the satellite image, generate the meshes and apply the required material. Each building is currently represented by a separate mesh as can be seen in the scene hierarchy window and is named from data in the GeoJSON. </p> <blockquote> <p>There is a whole load more metadata around the buildings in the data which could be surfaced in an app </p></blockquote> <h3>Mesh Creation</h3> <p>Once we have the GeoJSON in main memory we need to take the geometry data and convert to a polygonal mesh. The data has a list of ‘features’ in which can be found the buildings each with it’s own geometry defined. A quick scan of the data reveals different types of geometry which is specified as a collection of coordinates given in lat/long. I concentrated my efforts on the ‘polygon’ geometry type and used a polygon triangulator from <a href="http://wiki.unity3d.com/index.php?title=Triangulator" target="_blank">here</a> to convert the data to a mesh. Running this resulted in 2D polygons which could be extruded to the height of the associated building to give the final form of each building.</p> <blockquote> <p>The algorithm used here doesn’t support polygons with holes – this could be a future improvement</p></blockquote> <p>Here’s some pseudo-code for the creation of the 3D buildings:</p> <blockquote> <p>FOREACH Building<br>&nbsp;&nbsp;&nbsp; FOREACH GEOMETRY<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Convert Lat/Long to metres<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Convert from X/Y plane to X/Z plane<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move Centre of polygon to the origin<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Triangulate &amp; extrude <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Calculate UV coordinates<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Translate back out to original location<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Apply material<br>&nbsp;&nbsp;&nbsp; END<br>END</p> <p>Create a plane representing the ground tile<br></p></blockquote> <p>Notice that some work is done here to ‘create’ the mesh centred on the origin and then use it’s transform to translate it back into position. Also notice that there are steps to generate UV coordinates and apply a material. This is to enable a satellite image to be textured onto the buildings (more on that later). I found some code here <a title="http://stackoverflow.com/questions/12896139/geographic-coordinates-converter" href="http://stackoverflow.com/questions/12896139/geographic-coordinates-converter">http://stackoverflow.com/questions/12896139/geographic-coordinates-converter</a> which I used to enable the conversion from Lat/Long coordinates to metres.&nbsp; </p> <h3>GeoJSON API</h3> <p>I had made an earlier assumption that GeoJSON data would be easy to get via an API but at this point I’m not so sure as I couldn’t find a free API which provided it. As a result I decided to roll my own API as well. The API I created makes a call to the Overpass API to retrieve data in OSM form and then I used an open source project <a href="https://github.com/jhuntoo/OsmToGeoJSON.Net" target="_blank">OSMToGeoJSON.NET</a> to convert the OSM to GeoJSON and return it. I created the API using ASP.NET core and just ran it locally whilst developing out the rest of the project. Here’s a snippet of code from the API which retrieves the GeoJSON from Overpass:<script src="https://gist.github.com/peted70/59535764179ccd6d2bd98f90635f5438.js"></script>&nbsp; </p> <h3>Texture</h3> <p>I decided to explore using some satellite imagery as a texture for the buildings and ground tile plane. I used the <a href="https://msdn.microsoft.com/en-us/library/ff701724.aspx" target="_blank">Bing Maps static map API</a> to retrieve an aerial satellite image using the same lat/long bounding box as was used in the request for the geometry data. I proxied these calls via my API also and it might make sense to combine them into one call for a bounding box as they naturally need to be called together. The UV texture coordinate calculations turned out to be a little bit more complicated as in order to work out which sub rectangle of the returned image corresponded to the bounding box it was necessary to make another API call to get the associated metadata and then use that in some simple calculations to work out the offsets correctly. Also, I gave no consideration to the texturing of the vertical walls of the buildings and as a result this doesn’t look too good and I wondered if using something like <a href="https://www.gamedev.net/blog/979/entry-2250761-triplanar-texturing-and-normal-mapping/" target="_blank">tri-planar texture mapping</a> would help but ultimately the image data for the side of the buildings is missing from the image. </p> <h3>Optimisation</h3> <p>All of the above is non-HoloLens specific but I wanted this to run well on a HoloLens so we need to go a bit further as the HoloLens is essentially a mobile device, with mobile CPU/GPU so we can’t just assume that everything is going to run at 60fps out of the box. In order to track the frame rate at which the device is running we can either use the HoloLens device portal or the FPSDisplay prefab from the <a href="https://github.com/Microsoft/HoloToolkit-Unity" target="_blank">HoloToolkit</a> which provides a UI element which stays in your field of view to show the current FPS. I use one of these in the sample in the <a href="https://github.com/peted70/geojsontomesh" target="_blank">repo for this project</a> on Github.</p> <p>To begin profiling on the HoloLens you need to navigate to the Build Settings in the Unity editor and make sure that the <strong>Development Build</strong> and <strong>Autoconnect Profiler</strong> options are both checked.</p> <blockquote> <p>Autoconnect Profiler will ensure that frames from the start of the run get captured</p></blockquote> <p><a href="{{ site.baseurl }}/assets/images/2017/02/buildsettingsprofiler.png"><img title="buildsettingsprofiler" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="buildsettingsprofiler" src="{{ site.baseurl }}/assets/images/2017/02/buildsettingsprofiler_thumb.png" width="742" height="713"></a></p> <p>Also, ensure that you have the <strong>InternetClient</strong> and <strong>InternetClientServer</strong> options checked in the Player settings. Now if you build and deploy your app to the HoloLens and then open the Unity Profiler window you should get an entry for your device in the <strong>active profiler </strong>dropdown at the top of the window.</p> <p><strong><a href="{{ site.baseurl }}/assets/images/2017/02/activeprofiler.png"><img title="activeprofiler" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="activeprofiler" src="{{ site.baseurl }}/assets/images/2017/02/activeprofiler_thumb.png" width="739" height="209"></a>&nbsp;</strong></p> <p>Now if you record you can collect some detailed profile information for each frame:</p> <p><a href="{{ site.baseurl }}/assets/images/2017/02/profiler-output.png"><img title="profiler-output" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="profiler-output" src="{{ site.baseurl }}/assets/images/2017/02/profiler-output_thumb.png" width="746" height="477"></a></p> <p>As you can see from the video below the app is running at a low frame rate – I haven’t given much thought to optimisation at this stage but in a subsequent post I will take a closer look at the data and try to get the app closer to 60 fps.</p><iframe height="315" src="https://www.youtube.com/embed/qqP62GQuKFY" frameborder="0" width="560" allowfullscreen></iframe>
